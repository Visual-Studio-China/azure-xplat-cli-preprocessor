namespace AzureXplatCliJsonToYml
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using Newtonsoft.Json.Linq;
    using YamlDotNet.Serialization;

    public class Program
    {
        private static readonly Serializer Ser = new SerializerBuilder().Build();

        /// <summary>
        /// expected arguments:
        /// mode name: currently azure cli mode (asm/arm)
        /// azureFilePath: .json file generated by command: azure help --json
        /// pluginsFilePath: .json file in source code repo
        /// destnation directory where generate .yml files to
        /// </summary>
        /// <param name="args"></param>
        public static void Main(string[] args)
        {
            try
            {
                if (null == args || 4 != args.Length || string.IsNullOrEmpty(args[0]))
                {
                    throw new Exception("Invalid arguments: expecting mode, azure .json file, plugins .json file and destination directory!");
                }
                if (!IsValidFile(args[1]))
                {
                    throw new Exception("Invalid arguments: please make sure the second argument is .json file and it does exist!");
                }
                if (!IsValidFile(args[2]))
                {
                    throw new Exception("Invalid arguments: please make sure the third argument is .json file and it does exist!");
                }

                SplitJsonToYamls(args[0], args[1], args[2], args[3]);
            }
            catch (Exception ex)
            {
                var color = Console.ForegroundColor;
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine(ex.ToString());
                Console.ForegroundColor = color;
            }
        }

        private static void SplitJsonToYamls(string mode, string azureFilePath, string pluginsFilePath, string destRoot)
        {
            if (string.IsNullOrEmpty(mode) || !IsValidFile(azureFilePath) || !IsValidFile(pluginsFilePath))
            {
                return;
            }

            var modeName = Constants.ModeNameMapping[mode];
            var modePath = Path.Combine(destRoot, modeName);
            var vm = new AzureXplatCliViewModel();
            using (var str = new StreamReader(azureFilePath))
            {
                var jobject = JObject.Parse(str.ReadToEnd());
                vm.Name = (string)jobject[Constants.Name];
                vm.Description = (string)jobject[Constants.Description];
                vm.Usage = (string)jobject[Constants.Usage];
            }

            // use plugins.arm/asm.json to set commands and categories to fullfill the filepath
            using (var str = new StreamReader(pluginsFilePath))
            {
                var jobject = JObject.Parse(str.ReadToEnd());
                vm.Commands = jobject[Constants.Commands].ToObject<List<Command>>();
                Directory.SetCurrentDirectory(destRoot);
                Save(modeName, vm);
                Directory.CreateDirectory(modePath);
                Directory.SetCurrentDirectory(modePath);
                if (null != jobject[Constants.Categories])
                {
                    ParseCategoriesRecursive(jobject);
                }
            }

            Directory.SetCurrentDirectory(modePath);
        }

        private static void ParseCategoriesRecursive(JToken jobject)
        {
            if (null == jobject?[Constants.Categories])
            {
                return;
            }
            
            var keys = JObject.Parse(jobject[Constants.Categories].ToString()).Properties().Select(p => p.Name).ToList();
            foreach (var key in keys)
            {
                var temp = jobject[Constants.Categories][key];
                var category = new AzureXplatCliViewModel
                {
                    Name = (string)temp[Constants.Name],
                    Description = (string)temp[Constants.Description],
                    Usage = (string)temp[Constants.Usage],
                    Commands = temp[Constants.Commands].ToObject<List<Command>>()
                };

                Save(category.Name, category);
                var categoriesCount = JObject.Parse(temp[Constants.Categories].ToString()).Properties().Select(p => p.Name).ToList().Count;

                if (null != temp[Constants.Categories] && 0 != categoriesCount)
                {
                    Directory.CreateDirectory(category.Name);
                    Directory.SetCurrentDirectory(Path.Combine(Directory.GetCurrentDirectory(), category.Name));
                    ParseCategoriesRecursive(temp);
                    Directory.SetCurrentDirectory(new DirectoryInfo(Directory.GetCurrentDirectory()).Parent.FullName);
                }
            }
        }

        private static bool IsValidFile(string path, string expectedExtension = Constants.SourceExtension)
        {
            return string.Equals(expectedExtension, Path.GetExtension(path)) && File.Exists(path);
        }

        private static void Save(string name, object obj)
        {
            var file = Path.Combine(Directory.GetCurrentDirectory(), string.Concat(name, Constants.DestExtension));

            using (var stw = new StreamWriter(file))
            {
                stw.Write("### ");
                stw.WriteLine(Constants.YamlMime.TrimEnd('\r'));
                stw.Write(Ser.Serialize(obj));
            }
        }
    }
}
